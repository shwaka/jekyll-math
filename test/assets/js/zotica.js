const DATA = {"radical":{"0":"√","1":"󰄝","2":"󰄞","3":"󰄟","height":[1486,2102,2623,3100]},"fence":{"paren":[{"0":"(","1":"󰀹","2":"󰀺","3":"󰀻","4":"󰀼","5":"󰀽","6":"󰀾","7":"󰀿","8":"󰁀","9":"󰁁","10":"󰁂","11":"󰁃","12":"󰁄","start":"⎛","bar":"⎜","end":"⎝"},{"0":")","1":"󰁅","2":"󰁆","3":"󰁇","4":"󰁈","5":"󰁉","6":"󰁊","7":"󰁋","8":"󰁌","9":"󰁍","10":"󰁎","11":"󰁏","12":"󰁐","start":"⎞","bar":"⎟","end":"⎠"}],"pparen":[{"0":"⦅","1":"󰈊","2":"󰈋","3":"󰈌","4":"󰈍"},{"0":"⦆","1":"󰈎","2":"󰈏","3":"󰈐","4":"󰈑"}],"bracket":[{"0":"[","1":"󰁑","2":"󰁒","3":"󰁓","4":"󰁔","5":"󰁕","6":"󰁖","7":"󰁗","8":"󰁘","9":"󰁙","10":"󰁚","11":"󰁛","12":"󰁜","start":"⎡","bar":"⎢","end":"⎣"},{"0":"]","1":"󰁝","2":"󰁞","3":"󰁟","4":"󰁠","5":"󰁡","6":"󰁢","7":"󰁣","8":"󰁤","9":"󰁥","10":"󰁦","11":"󰁧","12":"󰁨","start":"⎤","bar":"⎥","end":"⎦"}],"bbracket":[{"0":"⟦","1":"󰇨","2":"󰇩","3":"󰇪","4":"󰇫"},{"0":"⟧","1":"󰇬","2":"󰇭","3":"󰇮","4":"󰇯"}],"brace":[{"0":"{","1":"󰁩","2":"󰁪","3":"󰁫","4":"󰁬","5":"󰁭","6":"󰁮","7":"󰁯","8":"󰁰","9":"󰁱","10":"󰁲","11":"󰁳","12":"󰁴","start":"⎧","bar":"⎪","middle":"⎨","end":"⎩"},{"0":"}","1":"󰁵","2":"󰁶","3":"󰁷","4":"󰁸","5":"󰁹","6":"󰁺","7":"󰁻","8":"󰁼","9":"󰁽","10":"󰁾","11":"󰁿","12":"󰂀","start":"⎫","bar":"⎪","middle":"⎬","end":"⎭"}],"bbrace":[{"0":"⦃","1":"󰈂","2":"󰈃","3":"󰈄","4":"󰈅"},{"0":"⦄","1":"󰈆","2":"󰈇","3":"󰈈","4":"󰈉"}],"vert":[{"0":"|","bar":"|"},{"0":"|","bar":"|"}],"vvert":[{"0":"‖","bar":"‖"},{"0":"‖","bar":"‖"}],"floor":[{"0":"⌊","1":"󰆙","2":"󰆚","3":"󰆛","4":"󰆜"},{"0":"⌋","1":"󰆝","2":"󰆞","3":"󰆟","4":"󰆠"}],"ceil":[{"0":"⌈","1":"󰆑","2":"󰆒","3":"󰆓","4":"󰆔"},{"0":"⌉","1":"󰆕","2":"󰆖","3":"󰆗","4":"󰆘"}],"angle":[{"0":"⟨","1":"󰇰","2":"󰇱","3":"󰇲","4":"󰇳"},{"0":"⟩","1":"󰇴","2":"󰇵","3":"󰇶","4":"󰇷"}],"aangle":[{"0":"⟪","1":"󰇸","2":"󰇹","3":"󰇺","4":"󰇻"},{"0":"⟫","1":"󰇼","2":"󰇽","3":"󰇾","4":"󰇿"}],"tort":[{"0":"❲","1":"󰇠","2":"󰇡","3":"󰇢","4":"󰇣","start":"󰖤","bar":"󰖥","end":"󰖦"},{"0":"❳","1":"󰇤","2":"󰇥","3":"󰇦","4":"󰇧","start":"󰖧","bar":"󰖨","end":"󰖩"}]},"wide":{"widetilde":[null,{"0":"󰂡","1":"󰂢","2":"󰂣","3":"󰂤","4":"󰂥","width":[1002,1495,1931,2384,10000]}],"widehat":[null,{"0":"󰂗","1":"󰂘","2":"󰂙","3":"󰂚","4":"󰂛","width":[1002,1495,1931,2384,10000]}],"widecheck":[null,{"0":"󰂜","1":"󰂝","2":"󰂞","3":"󰂟","4":"󰂠","width":[1002,1495,1931,2384,10000]}],"overline":[null,{"0":"","bar":"󰂵"}],"overrarr":[null,{"0":"","bar":"󰃩","end":"󰃪"}],"overlarr":[null,{"0":"","end":"󰃤","bar":"󰃩"}],"overbrace":[null,{"0":"⏞","1":"󰇇","2":"󰇈","3":"󰇉","4":"󰇊","5":"󰇋","start":"󰇄","bar":"󰆪","middle":"󰇅","end":"󰇆","width":[1000,1500,1770,2180,2600,2850]}],"widetildebelow":[{"0":"󰂦","1":"󰂧","2":"󰂨","3":"󰂩","4":"󰂪","width":[1002,1495,1931,2384,10000]},null],"underline":[{"0":"","bar":"󰂒"},null],"underrarr":[{"0":"","bar":"󰃾","end":"󰃿"},null],"underlarr":[{"0":"","start":"󰃹","bar":"󰃾"},null],"underbrace":[{"0":"⏟","1":"󰇏","2":"󰇐","3":"󰇑","4":"󰇒","5":"󰇓","start":"󰇌","bar":"󰆲","middle":"󰇍","end":"󰇎","width":[1000,1500,1770,2180,2600,2850]},null]},"arrow":{"normal":{"edge":"end","x":0.3,"y":0.18,"width":0.3,"height":0.36,"extrusion":0,"command":"M 0 0 L 0.3 0.18 L 0 0.36"},"dnormal":{"edge":"end","x":0.21,"y":0.27,"width":0.3,"height":0.54,"extrusion":0.09,"command":"M 0 0 L 0.3 0.27 L 0 0.54"},"tnormal":{"edge":"end","x":0.15,"y":0.36,"width":0.3,"height":0.72,"extrusion":0.15,"command":"M 0 0 L 0.3 0.36 L 0 0.72 M 0.15 0.36 L 0.3 0.36"},"head":{"edge":"end","x":0.54,"y":0.18,"width":0.54,"height":0.36,"extrusion":0,"command":"M 0 0 L 0.3 0.18 L 0 0.36 M 0.24 0 L 0.54 0.18 L 0.24 0.36"},"tail":{"edge":"start","x":0.3,"y":0.18,"width":0.3,"height":0.36,"extrusion":0.3,"command":"M 0 0 L 0.3 0.18 L 0 0.36"},"hook":{"edge":"start","x":0.12,"y":0.3,"width":0.24,"height":0.3,"extrusion":0.18,"command":"M 0.18 0 L 0.12 0 A 0.15 0.15 0 0 0 0.12 0.3"},"varhook":{"edge":"start","x":0.12,"y":0,"width":0.24,"height":0.3,"extrusion":0.18,"command":"M 0.12 0 A 0.15 0.15 0 0 0 0.12 0.3 L 0.18 0.3"}}};
//


class Modifier {

  modify() {
    console.info("[Zotica] Start");
    let startDate = new Date();
    let elements = [];
    elements.push(...document.querySelectorAll("math-subsup"));
    elements.push(...document.querySelectorAll("math-underover"));
    elements.push(...document.querySelectorAll("math-rad.mod"));
    elements.push(...document.querySelectorAll("math-fence.mod"));
    elements.push(...document.querySelectorAll("math-diagram"));
    elements.push(...document.querySelectorAll("math-step"));
    elements = elements.sort((first, second) => {
      return this.getDepth(second) - this.getDepth(first);
    });
    elements.forEach((element) => {
      let name = element.localName;
      if (name == "math-subsup") {
        SubsuperModifier.execute(element);
      } else if (name == "math-underover") {
        UnderoverModifier.execute(element);
        if (element.classList.contains("wid") && element.classList.contains("mod")) {
          WideModifier.execute(element);
        }
      } else if (name == "math-rad") {
        RadicalModifier.execute(element);
      } else if (name == "math-fence") {
        FenceModifier.execute(element);
      } else if (name == "math-diagram") {
        DiagramModifier.execute(element);
      } else if (name == "math-step") {
        TreeModifier.execute(element);
      }
    });
    let finishDate = new Date();
    let elapsedTime = ((finishDate - startDate) / 1000).toFixed(4);
    console.info("[Zotica] Finish (" + elements.length + " elements, " + elapsedTime + " seconds)");
  }

  modifyDebug() {
    document.querySelectorAll("debug").forEach((element) => {
      let modifier = new Modifier();
      modifier.renderDebug(element);
    });
  }

  getFontSize(element) {
    let fontSizeString = window.getComputedStyle(element).fontSize;
    let fontSize = parseFloat(fontSizeString);
    return fontSize;
  }

  getWidthPx(element) {
    let width = element.getBoundingClientRect().width;
    return width;
  }

  getWidth(element, fontElement) {
    let width = this.getWidthPx(element) / this.getFontSize(fontElement || element);
    return width;
  }

  getHeightPx(element) {
    let height = element.getBoundingClientRect().height;
    return height;
  }

  getHeight(element, fontElement) {
    let height = this.getHeightPx(element) / this.getFontSize(fontElement || element);
    return height;
  }

  getLowerHeightPx(element) {
    let bottom = element.getBoundingClientRect().bottom + window.pageYOffset;
    let locator = document.createElement("math-sys-locator");
    element.appendChild(locator);
    locator.style.verticalAlign = "baseline";
    let baselineBottom = locator.getBoundingClientRect().bottom + window.pageYOffset;
    let height = bottom - baselineBottom + this.getFontSize(element) * 0.3;
    element.removeChild(locator);
    return height;
  }

  getLowerHeight(element, fontElement) {
    let height = this.getLowerHeightPx(element) / this.getFontSize(fontElement || element);
    return height;
  }

  getUpperHeightPx(element) {
    let height = this.getHeightPx(element) - this.getLowerHeightPx(element);
    return height;
  }

  getUpperHeight(element, fontElement) {
    let height = this.getHeight(element, fontElement) - this.getLowerHeight(element, fontElement);
    return height;
  }

  getOffsetLeft(element, fontElement) {
    let offset = element.offsetLeft / this.getFontSize(fontElement || element);
    return offset;
  }

  getOffsetRight(element, fontElement) {
    let offset = (element.offsetParent.offsetWidth - element.offsetLeft - element.offsetWidth) / this.getFontSize(fontElement || element);
    return offset;
  }

  getDepth(element) {
    let depth = 0;
    if (element.zoticaDepth != undefined) {
      depth = element.zoticaDepth;
    } else {
      let parent = element.parentNode;
      if (parent) {
        depth = this.getDepth(parent) + 1;
      } else {
        depth = 0;
      }
    }
    element.zoticaDepth = depth;
    return depth;
  }  

  findChild(element, name) {
    return Array.from(element.children).find((child) => child.localName == name);
  }

  findChildren(element, name) {
    return Array.from(element.children).filter((child) => child.localName == name);
  }

  renderDebug(element) {
    let clientRect = element.getBoundingClientRect();
    let scrollOffset = window.pageYOffset;
    let lowerHeight = this.getLowerHeightPx(element);
    let upperHeight = this.getUpperHeightPx(element);
    let line = document.createElement("div");
    let upperBox = document.createElement("div");
    let lowerBox = document.createElement("div");
    line.style.position = "absolute";
    line.style.borderTop = "1px #FF000088 solid";
    line.style.width = "" + clientRect.width + "px";
    line.style.height = "1px";
    line.style.top = "" + (clientRect.bottom - lowerHeight + scrollOffset) + "px";
    line.style.left = "" + clientRect.left + "px";
    lowerBox.style.position = "absolute";
    lowerBox.style.backgroundColor = "#FFFF0033";
    lowerBox.style.width = "" + clientRect.width + "px";
    lowerBox.style.height = "" + lowerHeight + "px";
    lowerBox.style.top = "" + (clientRect.top + upperHeight + scrollOffset) + "px";
    lowerBox.style.left = "" + clientRect.left + "px";
    upperBox.style.position = "absolute";
    upperBox.style.backgroundColor = "#FF000033";
    upperBox.style.width = "" + clientRect.width + "px";
    upperBox.style.height = "" + upperHeight + "px";
    upperBox.style.top = "" + (clientRect.top + scrollOffset) + "px";
    upperBox.style.left = "" + clientRect.left + "px";
    document.body.appendChild(line);
    document.body.appendChild(lowerBox);
    document.body.appendChild(upperBox);
  }

  static execute(element) {
    let modifier = new this();
    modifier.modify(element);
  }

}
//


const ANGLE_EPSILON = Math.PI / 90;

const UNIT = 1 / 18;
const ARROW_MARGIN = 8 * UNIT;
const LABEL_DISTANCE = 5 * UNIT;


class DiagramModifier extends Modifier {

  modify(element) {
    let arrowElements = this.findChildren(element, "math-arrow");
    let cellElements = this.findChildren(element, "math-cellwrap").map((child) => child.children[0]);
    let backgroundColor = this.getBackgroundColor(element);
    let graphic = this.createGraphic(element);
    element.appendChild(graphic);
    for (let arrowElement of arrowElements) {
      let arrowSpec = this.determineArrowSpec(graphic, arrowElement, cellElements, arrowElements);
      let arrows = this.createArrows(arrowSpec, backgroundColor);
      graphic.append(...arrows);
      let labelPoint = this.determineLabelPoint(graphic, arrowElement, arrowSpec);
      let fontRatio = this.getFontSize(graphic) / this.getFontSize(arrowElement);
      arrowElement.style.left = "" + (labelPoint[0] * fontRatio) + "em";
      arrowElement.style.top = "" + (labelPoint[1] * fontRatio) + "em";
    }
    let pathElements = Array.from(graphic.children).filter((child) => child.localName == "path");
    let extrusion = this.calcExtrusion(graphic, arrowElements.concat(pathElements));
    element.style.marginTop = "" + extrusion.top + "em";
    element.style.marginBottom = "" + extrusion.bottom + "em";
    element.style.marginLeft = "" + extrusion.left + "em";
    element.style.marginRight = "" + extrusion.right + "em";
  }

  determineArrowSpec(graphic, arrowElement, cellElements, arrowElements) {
    let spec = {};
    let startConfigString = arrowElement.getAttribute("data-start");
    let endConfigString = arrowElement.getAttribute("data-end");
    let startConfig = this.parseEdgeConfig(startConfigString, graphic, cellElements, arrowElements);
    let endConfig = this.parseEdgeConfig(endConfigString, graphic, cellElements, arrowElements);
    if (startConfig && endConfig) {
      let bendAngleString = arrowElement.getAttribute("data-bend");
      if (bendAngleString) {
        spec.bendAngle = parseFloat(bendAngleString) * Math.PI / 180;
      }
      let shiftString = arrowElement.getAttribute("data-shift");
      if (shiftString) {
        spec.shift = parseFloat(shiftString) * UNIT;
      }
      let startElement = startConfig.element;
      let endElement = endConfig.element;
      let startDimension = startConfig.dimension;
      let endDimension = endConfig.dimension;
      if (startConfig.point) {
        spec.startPoint = startConfig.point;
      } else {
        spec.startPoint = this.calcEdgePoint(startDimension, endDimension, spec.bendAngle, spec.shift);
      }
      if (endConfig.point) {
        spec.endPoint = endConfig.point;
      } else {
        spec.endPoint = this.calcEdgePoint(endDimension, startDimension, -spec.bendAngle, -spec.shift);
      }
    } else {
      spec.startPoint = [0, 0];
      spec.endPoint = [0, 0];
    }
    let labelPositionString = arrowElement.getAttribute("data-pos");
    if (labelPositionString) {
      spec.labelPosition = parseFloat(labelPositionString) / 100;
    }
    let lineCountString = arrowElement.getAttribute("data-line");
    if (lineCountString) {
      spec.lineCount = parseInt(lineCountString);
    }
    let dashed = !!arrowElement.getAttribute("data-dash");
    if (dashed) {
      spec.dashed = true;
    }
    let inverted = !!arrowElement.getAttribute("data-inv");
    if (inverted) {
      spec.inverted = true;
    }
    let mark = !!arrowElement.getAttribute("data-mark");
    if (mark) {
      spec.mark = true;
    }
    let tipKindsString = arrowElement.getAttribute("data-tip");
    spec.tipKinds = this.parseTipKinds(tipKindsString, spec.lineCount);
    spec.intrudedStartPoint = this.calcIntrudedPoint(spec.startPoint, spec.endPoint, spec.bendAngle, spec.tipKinds.start);
    spec.intrudedEndPoint = this.calcIntrudedPoint(spec.endPoint, spec.startPoint, -spec.bendAngle, spec.tipKinds.end);
    return spec;
  }

  determineLabelPoint(graphic, labelElement, arrowSpec) {
    let labelDimension = this.calcDimension(graphic, labelElement);
    let startPoint = arrowSpec.startPoint;
    let endPoint = arrowSpec.endPoint;
    let bendAngle = arrowSpec.bendAngle;
    let position = (arrowSpec.labelPosition == undefined) ? 0.5 : arrowSpec.labelPosition;
    let basePoint = [0, 0];
    let angle = 0;
    if (bendAngle != undefined) {
      let controlPoint = this.calcControlPoint(startPoint, endPoint, bendAngle);
      let basePointX = (1 - position) * (1 - position) * startPoint[0] + 2 * (1 - position) * position * controlPoint[0] + position * position * endPoint[0];
      let basePointY = (1 - position) * (1 - position) * startPoint[1] + 2 * (1 - position) * position * controlPoint[1] + position * position * endPoint[1];
      let speedX = -2 * (1 - position) * startPoint[0] + 2 * (1 - 2 * position) * controlPoint[0] + 2 * position * endPoint[0];
      let speedY = -2 * (1 - position) * startPoint[1] + 2 * (1 - 2 * position) * controlPoint[1] + 2 * position * endPoint[1];
      basePoint = [basePointX, basePointY];
      angle = this.calcAngle([0, 0], [speedX, speedY]) + Math.PI / 2;
    } else {
      let basePointX = (1 - position) * startPoint[0] + position * endPoint[0];
      let basePointY = (1 - position) * startPoint[1] + position * endPoint[1];
      basePoint = [basePointX, basePointY];
      angle = this.calcAngle(startPoint, endPoint) + Math.PI / 2;
    }
    if (arrowSpec.inverted) {
      angle += Math.PI;
    }
    angle = this.normalizeAngle(angle);
    let point;
    if (arrowSpec.mark) {
      let pointX = basePoint[0] + labelDimension.northWest[0] - labelDimension.center[0];
      let pointY = basePoint[1] + labelDimension.northWest[0] - labelDimension.center[1];
      point = [pointX, pointY];
    } else {
      point = this.calcLabelPoint(basePoint, labelDimension, angle, arrowSpec.lineCount);
    }
    return point;
  }

  calcEdgePoint(baseDimension, destinationDimension, bendAngle, shift) {
    let margin = ARROW_MARGIN;
    let angle = this.calcAngle(baseDimension.center, destinationDimension.center) + (bendAngle || 0);
    let shiftAngle = angle + Math.PI / 2;
    let southWestAngle = this.calcAngle(baseDimension.center, baseDimension.southWestMargined);
    let southEastAngle = this.calcAngle(baseDimension.center, baseDimension.southEastMargined);
    let northEastAngle = this.calcAngle(baseDimension.center, baseDimension.northEastMargined);
    let northWestAngle = this.calcAngle(baseDimension.center, baseDimension.northWestMargined);
    let x = 0;
    let y = 0;
    angle = this.normalizeAngle(angle);
    shiftAngle = this.normalizeAngle(shiftAngle);
    if (angle >= southWestAngle && angle <= southEastAngle) {
      x = baseDimension.center[0] + (baseDimension.center[1] - baseDimension.southMargined[1]) / Math.tan(angle);
      y = baseDimension.southMargined[1];
    } else if (angle >= southEastAngle && angle <= northEastAngle) {
      x = baseDimension.eastMargined[0];
      y = baseDimension.center[1] + (baseDimension.center[0] - baseDimension.eastMargined[0]) * Math.tan(angle);
    } else if (angle >= northEastAngle && angle <= northWestAngle) {
      x = baseDimension.center[0] + (baseDimension.center[1] - baseDimension.northMargined[1]) / Math.tan(angle);
      y = baseDimension.northMargined[1];
    } else if (angle >= northWestAngle || angle <= southWestAngle) {
      x = baseDimension.westMargined[0];
      y = baseDimension.center[1] + (baseDimension.center[0] - baseDimension.westMargined[0]) * Math.tan(angle);
    }
    if (shift) {
      x += Math.cos(shiftAngle) * shift;
      y -= Math.sin(shiftAngle) * shift;
    }
    return [x, y];
  }

  calcIntrudedPoint(basePoint, destinationPoint, bendAngle, tipKind) {
    if (tipKind != "none") {
      let angle = this.calcAngle(basePoint, destinationPoint) + (bendAngle || 0);
      let distance = DATA["arrow"][tipKind]["extrusion"];
      angle = this.normalizeAngle(angle);
      let intrudedPointX = basePoint[0] + distance * Math.cos(angle);
      let intrudedPointY = basePoint[1] - distance * Math.sin(angle);
      let intrudedPoint = [intrudedPointX, intrudedPointY];
      return intrudedPoint;
    } else {
      return basePoint;
    }
  }

  calcLabelPoint(basePoint, labelDimension, angle, lineCount) {
    let distance = LABEL_DISTANCE + ((lineCount || 1) - 1) * 0.09;
    let direction = "east";
    if (angle <= -Math.PI + ANGLE_EPSILON) {
      direction = "east";
    } else if (angle <= -Math.PI / 2 - ANGLE_EPSILON) {
      direction = "northEast";
    } else if (angle <= -Math.PI / 2 + ANGLE_EPSILON) {
      direction = "north";
    } else if (angle <= -ANGLE_EPSILON) {
      direction = "northWest";
    } else if (angle <= ANGLE_EPSILON) {
      direction = "west";
    } else if (angle <= Math.PI / 2 - ANGLE_EPSILON) {
      direction = "southWest";
    } else if (angle <= Math.PI / 2 + ANGLE_EPSILON) {
      direction = "south";
    } else if (angle <= Math.PI - ANGLE_EPSILON) {
      direction = "southEast";
    } else {
      direction = "east";
    }
    let x = basePoint[0] + Math.cos(angle) * distance + labelDimension.northWest[0] - labelDimension[direction][0];
    let y = basePoint[1] - Math.sin(angle) * distance + labelDimension.northWest[1] - labelDimension[direction][1];
    return [x, y];
  }

  parseEdgeConfig(string, graphic, cellElements, arrowElements) {
    let config = null;
    let match = string.match(/(?:(\d+)|([A-Za-z]\w*))(?:\:(\w+))?/);
    if (match) {
      let element = null;
      if (match[1]) {
        let number = parseInt(match[1]) - 1;
        element = cellElements[number];
      } else if (match[2]) {
        let candidates = cellElements.map((candidate) => candidate.parentNode).concat(arrowElements);
        let name = match[2];
        element = candidates.find((candidate) => candidate.getAttribute("data-name") == name);
      }
      if (element) {
        let dimension = this.calcDimension(graphic, element);
        let point = null;
        if (match[3]) {
          point = this.parsePoint(match[3], dimension);
        }
        config = {element, dimension, point};
      }
    }
    return config;
  }

  parsePoint(string, dimension) {
    let point = null;
    let match;
    if (match = string.match(/^n(|w|e)|s(|w|e)|w|e|c$/)) {
      if (string == "nw") {
        point = dimension.northWestMargined;
      } else if (string == "n") {
        point = dimension.northMargined;
      } else if (string == "ne") {
        point = dimension.northEastMargined;
      } else if (string == "e") {
        point = dimension.eastMargined;
      } else if (string == "se") {
        point = dimension.southEastMargined;
      } else if (string == "s") {
        point = dimension.southMargined;
      } else if (string == "sw") {
        point = dimension.southWestMargined;
      } else if (string == "w") {
        point = dimension.westMargined;
      } else if (string == "c") {
        point = dimension.center;
      }
    } else if (match = string.match(/^(t|r|b|l)([\d.]+)$/)) {
      let direction = match[1];
      let position = parseFloat(match[2]) / 100;
      let pointX = null;
      let pointY = null;
      if (direction == "t") {
        pointX = (1 - position) * dimension.northWestMargined[0] + position * dimension.northEastMargined[0];
        pointY = dimension.northMargined[1];
      } else if (direction == "r") {
        pointX = dimension.eastMargined[0];
        pointY = (1 - position) * dimension.northEastMargined[1] + position * dimension.southEastMargined[1];
      } else if (direction == "b") {
        pointX = (1 - position) * dimension.southWestMargined[0] + position * dimension.southEastMargined[0];
        pointY = dimension.southMargined[1];
      } else if (direction == "l") {
        pointX = dimension.westMargined[0];
        pointY = (1 - position) * dimension.northWestMargined[1] + position * dimension.southWestMargined[1];
      }
      if (pointX != null && pointY != null) {
        point = [pointX, pointY];
      }
    }
    return point;
  }

  parseTipKinds(string, lineCount) {
    let tipKinds = {start: "none", end: "normal"};
    if (string != null) {
      let specifiedTipKinds = string.split(/\s*,\s*/);
      for (let specifiedTipKind of specifiedTipKinds) {
        let spec = DATA["arrow"][specifiedTipKind];
        if (spec) {
          tipKinds[spec.edge] = specifiedTipKind;
        }
        if (specifiedTipKind == "none") {
          tipKinds.end = "none";
        }
      }
    }
    if (lineCount == 2) {
      if (tipKinds.start != "none") {
        tipKinds.start = "d" + tipKinds.start;
      }
      if (tipKinds.end != "none") {
        tipKinds.end = "d" + tipKinds.end;
      }
    } else if (lineCount == 3) {
      if (tipKinds.start != "none") {
        tipKinds.start = "t" + tipKinds.start;
      }
      if (tipKinds.end != "none") {
        tipKinds.end = "t" + tipKinds.end;
      }
    }
    return tipKinds;
  }

  calcAngle(basePoint, destinationPoint) {
    let x = destinationPoint[0] - basePoint[0];
    let y = destinationPoint[1] - basePoint[1];
    let angle = -Math.atan2(y, x);
    return angle;
  }

  normalizeAngle(angle) {
    let normalizedAngle = (angle + Math.PI) % (Math.PI * 2) - Math.PI;
    return normalizedAngle;
  }

  createArrows(arrowSpec, backgroundColor) {
    let startPoint = arrowSpec.intrudedStartPoint;
    let endPoint = arrowSpec.intrudedEndPoint;
    let bendAngle = arrowSpec.bendAngle;
    let lineCount = (arrowSpec.lineCount == undefined) ? 1 : arrowSpec.lineCount;
    let command = "M " + startPoint[0] + " " + startPoint[1];
    if (bendAngle != undefined) {
      let controlPoint = this.calcControlPoint(startPoint, endPoint, bendAngle)
      command += " Q " + controlPoint[0] + " " + controlPoint[1] + ", " + endPoint[0] + " " + endPoint[1];
    } else {
      command += " L " + endPoint[0] + " " + endPoint[1];
    }
    let arrows = [];
    for (let i = 0 ; i < lineCount ; i ++) {
      let arrow = this.createSvgElement("path");
      arrow.setAttribute("d", command);
      if (arrowSpec.tipKinds.start != "none" && i == lineCount - 1) {
        arrow.setAttribute("marker-start", "url(#tip-" + arrowSpec.tipKinds.start +")");
      }
      if (arrowSpec.tipKinds.end != "none" && i == lineCount - 1) {
        arrow.setAttribute("marker-end", "url(#tip-" + arrowSpec.tipKinds.end + ")");
      }
      if (arrowSpec.dashed && i % 2 == 0) {
        arrow.classList.add("dashed");
      }
      if (i == 0) {
        arrow.classList.add("base");
      } else if (i == 1) {
        arrow.classList.add("cover");
        arrow.style.stroke = backgroundColor;
      } else if (i == 2) {
        arrow.classList.add("front");
      }
      if (lineCount == 2) {
        arrow.classList.add("double");
      } else if (lineCount == 3) {
        arrow.classList.add("triple");
      }
      arrows.push(arrow);
    }
    return arrows;
  }

  calcControlPoint(startPoint, endPoint, bendAngle) {
    let x = (endPoint[0] + startPoint[0] + (endPoint[1] - startPoint[1]) * Math.tan(bendAngle)) / 2;
    let y = (endPoint[1] + startPoint[1] - (endPoint[0] - startPoint[0]) * Math.tan(bendAngle)) / 2;
    return [x, y];
  }

  calcExtrusion(graphic, elements) {
    let fontSize = this.getFontSize(graphic);
    let xOffset =  window.pageXOffset;
    let yOffset =  window.pageYOffset;
    let graphicRect = graphic.getBoundingClientRect();
    let graphicTop = graphicRect.top + yOffset
    let graphicBottom = graphicRect.bottom + yOffset;
    let graphicLeft = graphicRect.left + xOffset;
    let graphicRight = graphicRect.right + xOffset;
    let extrusion = {top: 0, bottom: 0, left: 0, right: 0};
    for (let element of elements) {
      let rect = element.getBoundingClientRect();
      let topExtrusion = -(rect.top + yOffset - graphicTop) / fontSize;
      let bottomExtrusion = (rect.bottom + yOffset - graphicBottom) / fontSize;
      let leftExtrusion = -(rect.left + xOffset - graphicLeft) / fontSize;
      let rightExtrusion = (rect.right + xOffset - graphicRight) / fontSize;
      if (topExtrusion > extrusion.top) {
        extrusion.top = topExtrusion;
      }
      if (bottomExtrusion > extrusion.bottom) {
        extrusion.bottom = bottomExtrusion;
      }
      if (leftExtrusion > extrusion.left) {
        extrusion.left = leftExtrusion;
      }
      if (rightExtrusion > extrusion.right) {
        extrusion.right = rightExtrusion;
      }
    }
    return extrusion;
  }

  createGraphic(element) {
    let width = this.getWidth(element);
    let height = this.getHeight(element);
    let graphic = this.createSvgElement("svg");
    graphic.setAttribute("viewBox", "0 0 " + width + " " + height);
    let definitionElement = this.createSvgElement("defs");
    let tipSpecKeys = Object.keys(DATA["arrow"]);
    for (let tipSpecKey of tipSpecKeys) {
      let tipSpec = DATA["arrow"][tipSpecKey];
      let markerElement = this.createSvgElement("marker");
      let markerPathElement = this.createSvgElement("path");
      markerElement.setAttribute("id", "tip-" + tipSpecKey);
      markerElement.setAttribute("refX", tipSpec["x"]);
      markerElement.setAttribute("refY", tipSpec["y"]);
      markerElement.setAttribute("markerWidth", tipSpec["width"]);
      markerElement.setAttribute("markerHeight", tipSpec["height"]);
      markerElement.setAttribute("markerUnits", "userSpaceOnUse");
      markerElement.setAttribute("orient", "auto");
      markerPathElement.setAttribute("d", tipSpec["command"]);
      markerElement.appendChild(markerPathElement);
      definitionElement.appendChild(markerElement);
    }
    graphic.appendChild(definitionElement);
    return graphic;
  }

  createSvgElement(name) {
    let element = document.createElementNS("http://www.w3.org/2000/svg", name);
    return element;
  }

  calcDimension(graphic, element) {
    let dimension = {};
    let margin = ARROW_MARGIN;
    let fontSize = this.getFontSize(graphic)
    let graphicTop = graphic.getBoundingClientRect().top + window.pageYOffset;
    let graphicLeft = graphic.getBoundingClientRect().left + window.pageXOffset;
    let top = (element.getBoundingClientRect().top + window.pageYOffset - graphicTop) / fontSize;
    let left = (element.getBoundingClientRect().left + window.pageXOffset - graphicLeft) / fontSize;
    let width = this.getWidth(element, graphic);
    let height = this.getHeight(element, graphic);
    let lowerHeight = this.getLowerHeight(element, graphic);
    dimension.northWest = [left, top];
    dimension.north = [left + width / 2, top];
    dimension.northEast = [left + width, top];
    dimension.west = [left, top + height - lowerHeight];
    dimension.center = [left + width / 2, top + height - lowerHeight];
    dimension.east = [left + width, top + height - lowerHeight];
    dimension.southWest = [left, top + height];
    dimension.south = [left + width / 2, top + height];
    dimension.southEast = [left + width, top + height];
    dimension.northWestMargined = [left - margin, top - margin];
    dimension.northMargined = [left + width / 2, top - margin];
    dimension.northEastMargined = [left + width + margin, top - margin];
    dimension.westMargined = [left - margin, top + height - lowerHeight];
    dimension.centerMargined = [left + width / 2, top + height - lowerHeight];
    dimension.eastMargined = [left + width + margin, top + height - lowerHeight];
    dimension.southWestMargined = [left - margin, top + height + margin];
    dimension.southMargined = [left + width / 2, top + height + margin];
    dimension.southEastMargined = [left + width + margin, top + height + margin];
    return dimension;
  }

  getBackgroundColor(element) {
    let currentElement = element;
    let color = "white";
    while (currentElement && currentElement instanceof Element) {
      let currentColor = window.getComputedStyle(currentElement).backgroundColor;
      if (currentColor != "rgba(0, 0, 0, 0)" && currentColor != "transparent") {
        color = currentColor;
        break;
      }
      currentElement = currentElement.parentNode;
    }
    return color;
  }

}
//


class SubsuperModifier extends Modifier {

  modify(element) {
    let baseElement = this.findChild(element, "math-base");
    let subElement = this.findChild(element, "math-sub");
    let superElement = this.findChild(element, "math-sup");
    let leftSubElement = this.findChild(element, "math-lsub");
    let leftSuperElement = this.findChild(element, "math-lsup");
    this.modifySide(element, baseElement, subElement, superElement, "right");
    this.modifySide(element, baseElement, leftSubElement, leftSuperElement, "left");
  }

  modifySide(element, baseElement, subElement, superElement, side) {
    let bothShifts = this.calcBothShifts(baseElement, subElement, superElement);
    let subShift = bothShifts.sub;
    let superShift = bothShifts.super;
    let subMargin = 0;
    let superMargin = (subElement) ? -this.getWidth(subElement) : 0;
    let subWidth = (subElement) ? this.getWidth(subElement) : 0;
    let superWidth = (superElement) ? this.getWidth(superElement) : 0;
    if (side == "right" && element.classList.contains("int")) {
      let slope = (element.classList.contains("inl")) ? 0.3 : 0.6
      subWidth -= slope;
      subMargin -= slope;
      if (subElement) {
        superMargin += slope;
      }
    }
    if (subElement) {
      subElement.style.verticalAlign = "" + subShift + "em";
      subElement.style.marginLeft = "" + subMargin + "em";
    }
    if (superElement) {
      superElement.style.verticalAlign = "" + superShift + "em";
      superElement.style.marginLeft = "" + superMargin + "em";
    }
    if (side == "right" && superElement && subWidth > superWidth) {
      superElement.style.width = "" + subWidth + "em";
    }
    if (side == "left" && subElement && superWidth > subWidth) {
      subElement.style.width = "" + superWidth + "em";
    }
  }

  calcBothShifts(baseElement, subElement, superElement) {
    let subShift = (subElement) ? this.calcSubShift(baseElement, subElement) : 0;
    let superShift = (superElement) ? this.calcSuperShift(baseElement, superElement) : 0;
    if (subElement && superElement) {
      let subHeight = this.getHeight(subElement);
      let gap = -subShift + superShift - subHeight;
      if (gap < 0.2) {
        subShift -= (0.2 - gap) / 2;
        superShift += (0.2 - gap) / 2;
      }
    }
    return {sub: subShift, super: superShift};
  }

  calcSubShift(baseElement, subElement) {
    let fontRatio = this.getFontSize(baseElement) / this.getFontSize(subElement);
    let height = this.getLowerHeight(baseElement);
    if (height < 0.4875) {
      height = 0.4875;
    }
    let shiftConst = -0.25;
    if (baseElement.parentNode.classList.contains("int") && !baseElement.parentNode.classList.contains("inl")) {
      shiftConst = -0.15;
    }
    let shift = (height + shiftConst) * fontRatio;
    return -shift;
  }

  calcSuperShift(baseElement, superElement) {
    let fontRatio = this.getFontSize(baseElement) / this.getFontSize(superElement);
    let height = this.getUpperHeight(baseElement);
    if (height < 0.5125) {
      height = 0.5125;
    }
    let shiftConst = -0.2;
    if (baseElement.parentNode.classList.contains("int") && !baseElement.parentNode.classList.contains("inl")) {
      shiftConst = -0.1;
    }
    let shift = (height + shiftConst) * fontRatio;
    return shift;
  }

}
//


class TreeModifier extends Modifier {

  modify(element) {
    let antecendentContainerElement = this.findChild(element, "math-ant");
    let firstAntecedentElement = antecendentContainerElement.children[0];
    let lastAntecedentElement = antecendentContainerElement.children[antecendentContainerElement.children.length - 1];
    let firstContentElement = this.calcContentElement(firstAntecedentElement);
    let lastContentElement = this.calcContentElement(lastAntecedentElement);
    let leftLabelElement = element.previousElementSibling;
    let rightLabelElement = element.nextElementSibling;
    let consequentWrapperElement = this.findChild(element, "math-conwrap");
    let lineElement = this.findChild(consequentWrapperElement, "math-line");
    let consequentElement = this.findChild(consequentWrapperElement, "math-con");
    let contentElement = this.findChild(consequentElement, "math-cont");
    let fontRatio = this.getFontSize(element) / this.getFontSize(leftLabelElement);
    let leftLabelWidth = this.getWidth(leftLabelElement, element);
    let rightLabelWidth = this.getWidth(rightLabelElement, element);
    let contentWidth = this.getWidth(contentElement);
    let wholeWidth = this.getWidth(element);
    let leftExtrusion = 0;
    let rightExtrusion = 0;
    if (firstContentElement && firstContentElement.localName != "math-axiom") {
      leftExtrusion = this.getOffsetLeft(firstContentElement);
    }
    if (lastContentElement && lastContentElement.localName != "math-axiom") {
      rightExtrusion = this.getOffsetRight(lastContentElement);
    }
    let lineWidth = wholeWidth - leftExtrusion - rightExtrusion;
    let leftMargin = (lineWidth - contentWidth) / 2 + leftExtrusion;
    consequentElement.style.setProperty("margin-left", "" + leftMargin + "em");
    if (leftExtrusion > this.getOffsetLeft(contentElement) - leftLabelWidth) {
      leftExtrusion = this.getOffsetLeft(contentElement) - leftLabelWidth;
    }
    if (rightExtrusion > this.getOffsetRight(contentElement) - rightLabelWidth) {
      rightExtrusion = this.getOffsetRight(contentElement) - rightLabelWidth;
    }
    lineWidth = wholeWidth - leftExtrusion - rightExtrusion;
    lineElement.style.setProperty("width", "" + lineWidth + "em", "important");
    lineElement.style.setProperty("margin-left", "" + leftExtrusion + "em", "important");
    element.style.setProperty("margin-right", "" + (-rightExtrusion) + "em", "important");
    if (rightLabelWidth < rightExtrusion) {
      rightLabelElement.style.setProperty("margin-right", "" + ((rightExtrusion - rightLabelWidth) * fontRatio) + "em", "important");
    }
    element.style.setProperty("margin-left", "" + (-leftExtrusion) + "em", "important");
    if (leftLabelWidth < leftExtrusion) {
      leftLabelElement.style.setProperty("margin-left", "" + ((leftExtrusion - leftLabelWidth) * fontRatio) + "em", "important");
    }
  }

  calcContentElement(antecedentElement) {
    let contentElement = null;
    if (antecedentElement) {
      if (antecedentElement.localName == "math-axiom") {
        contentElement = antecedentElement;
      } else {
        let stepElement = this.findChild(antecedentElement, "math-step");
        let consequenceWrapperElement = this.findChild(stepElement, "math-conwrap");
        let consequentElement = this.findChild(consequenceWrapperElement, "math-con");
        contentElement = this.findChild(consequentElement, "math-cont");
      }
    }
    return contentElement;
  }

}
//


class FenceModifier extends Modifier {

  modify(element) {
    let contentElements = this.findChildren(element, "math-cont");
    let leftElement = this.findChild(element, "math-left");
    let rightElement = this.findChild(element, "math-right");
    let centerElement = this.findChild(element, "math-center");
    let parentElements = [leftElement, rightElement, centerElement];
    let kinds = this.calcKinds(element);
    for (let position of [0, 1, 2]) {
      let parentElement = parentElements[position];
      let kind = kinds[position];
      if (position == 2) {
        position = 0;
      }
      if (parentElement && kind != "none") {
        let stretchLevel = this.calcStretchLevel(contentElements, kind, position);
        if (stretchLevel != null) {
          this.modifyStretch(contentElements, parentElement, kind, stretchLevel, position);
        } else {
          this.appendStretch(contentElements, parentElement, kind, position);
        }
      }
    }
  }

  modifyStretch(contentElements, parentElement, kind, stretchLevel, position) {
    let symbolElement = parentElement.children[0];
    let shift = this.calcShift(contentElements, stretchLevel);
    symbolElement.textContent = DATA["fence"][kind][position][stretchLevel];
    parentElement.style.verticalAlign = "" + shift + "em";
  }

  appendStretch(contentElements, parentElement, kind, position) {
    let stretchElement = document.createElement("math-vstretch");
    let hasStart = !!DATA["fence"][kind][position]["start"];
    let hasEnd = !!DATA["fence"][kind][position]["end"];
    let hasMiddle = !!DATA["fence"][kind][position]["middle"];
    let startElement = null;
    let endElement = null;
    let middleElement = null;
    if (hasStart) {
      startElement = document.createElement("math-start");
      startElement.textContent = DATA["fence"][kind][position]["start"];
      stretchElement.append(startElement);
    }
    if (hasMiddle) {
      middleElement = document.createElement("math-middle");
      middleElement.textContent = DATA["fence"][kind][position]["middle"];
      stretchElement.append(middleElement);
    }
    if (hasEnd) {
      endElement = document.createElement("math-end");
      endElement.textContent = DATA["fence"][kind][position]["end"];
      stretchElement.append(endElement);
    }
    parentElement.removeChild(parentElement.children[0]);
    parentElement.appendChild(stretchElement);
    let barSize = (hasMiddle) ? 2 : 1;
    let barHeight = this.calcBarHeight(contentElements, startElement, endElement, middleElement);
    let stretchShift = this.calcStretchShift(contentElements);
    for (let i = 0 ; i < barSize ; i ++) { 
      let barWrapperElement = document.createElement("math-barwrap");
      let barElement = document.createElement("math-bar");
      barElement.textContent = DATA["fence"][kind][position]["bar"];
      barWrapperElement.style.height = "" + barHeight + "em";
      barWrapperElement.append(barElement);
      if (i == 0) {
        stretchElement.insertBefore(barWrapperElement, stretchElement.children[(hasStart) ? 1 : 0]);
      } else {
        stretchElement.insertBefore(barWrapperElement, stretchElement.children[(hasStart) ? 3 : 2]);
      }
    }
    stretchElement.style.verticalAlign = "" + stretchShift + "em";
  }

  calcKinds(element) {
    let leftKind = "paren";
    let rightKind = "paren";
    let centerKind = "vert";
    if (element.getAttribute("data-left")) {
      leftKind = element.getAttribute("data-left");
    }
    if (element.getAttribute("data-right")) {
      rightKind = element.getAttribute("data-right");
    }
    if (element.getAttribute("data-center")) {
      centerKind = element.getAttribute("data-center");
    }
    return [leftKind, rightKind, centerKind];
  }

  calcMaxStretchLevel(kind, position) {
    let keys = Object.keys(DATA["fence"][kind][position]);
    let maxStretchLevel = 0;
    for (let key of keys) {
      if (key.match(/^\d+$/) && parseInt(key) > maxStretchLevel) {
        maxStretchLevel = parseInt(key);
      }
    }
    return maxStretchLevel;
  }

  calcWholeHeight(elements) {
    let upperHeights = [];
    let lowerHeights = [];
    for (let element of elements) {
      upperHeights.push(this.getUpperHeight(element));
      lowerHeights.push(this.getLowerHeight(element));
    }
    let maxUpperHeight = Math.max(...upperHeights);
    let maxLowerHeight = Math.max(...lowerHeights);
    return maxUpperHeight + maxLowerHeight;
  }

  calcStretchLevel(elements, kind, position) {
    let heightAbs = this.calcWholeHeight(elements) * 1000;
    let maxStretchLevel = this.calcMaxStretchLevel(kind, position);
    let stretchLevel = null;
    for (let i = 0 ; i <= maxStretchLevel ; i ++) {
      if (heightAbs <= 1059 + 242 * i) {
        stretchLevel = i;
        break;
      }
    }
    if (stretchLevel == null && !DATA["fence"][kind][position]["bar"]) {
      stretchLevel = maxStretchLevel;
    }
    return stretchLevel;
  }

  calcShift(elements, stretchLevel) {
    let shift = this.calcWholeHeight(elements) / 2 - Math.max(...elements.map((element) => this.getLowerHeight(element)));
    if (stretchLevel == 0) {
      shift = 0;
    }
    return shift;
  }

  calcBarHeight(elements, startElement, endElement, middleElement) {
    let wholeHeight = this.calcWholeHeight(elements);
    let startHeight = (startElement) ? this.getHeight(startElement) : 0;
    let endHeight = (endElement) ? this.getHeight(endElement) : 0;
    let middleHeight = (middleElement) ? this.getHeight(middleElement) : 0;
    let height = wholeHeight - startHeight - endHeight - middleHeight;
    if (middleElement) {
      height = height / 2;
    }
    if (height < 0) {
      height = 0;
    }
    return height;
  }

  calcStretchShift(elements) {
    let shift = Math.max(...elements.map((element) => this.getUpperHeight(element))) - 0.95;
    return shift;
  }

}
//


class RadicalModifier extends Modifier {

  modify(element) {
    let squareElement = this.findChild(element, "math-sqrt");
    let indexElement = this.findChild(element, "math-index");
    let surdElement = this.findChild(squareElement, "math-surd");
    let contentElement = this.findChild(squareElement, "math-cont");
    let surdSymbolElement = surdElement.children[0];
    let stretchLevel = this.calcStretchLevel(contentElement);
    surdSymbolElement.textContent = DATA["radical"][stretchLevel];
    if (indexElement) {
      this.modifyIndex(element, indexElement);
    }
  }

  modifyIndex(element, indexElement) {
    let width = this.getWidth(indexElement);
    let fontRatio = this.getFontSize(element) / this.getFontSize(indexElement);
    if (width / fontRatio < 0.5) {
      let margin = 0.5 * fontRatio - width;
      indexElement.style.marginLeft = "" + margin + "em";
    }
  }

  calcStretchLevel(element) {
    let heightAbs = this.getHeight(element) * 1000;
    let stretchLevel = null;
    for (let i = 0 ; i <= 3 ; i ++) {
      if (heightAbs <= DATA["radical"]["height"][i]) {
        stretchLevel = i;
        break;
      }
    }
    if (stretchLevel == null) {
      stretchLevel = 3;
    }
    return stretchLevel;
  }

}
//


class WideModifier extends Modifier {

  modify(element) {
    let baseWrapperElement = this.findChild(element, "math-basewrap");
    let overElement = this.findChild(element, "math-over");
    let contentElement = baseWrapperElement.children[0];
    let parentElements = [baseWrapperElement.children[1], overElement];
    let kind = this.calcKind(element);
    for (let position of [0, 1]) {
      let parentElement = parentElements[position];
      if (parentElement) {
        let stretchLevel = this.calcStretchLevel(contentElement, kind, position);
        if (stretchLevel != null) {
          this.modifyStretch(contentElement, parentElement, kind, stretchLevel, position);
        } else {
          this.appendStretch(contentElement, parentElement, kind, position);
        }
      }
    }
  }

  modifyStretch(contentElement, parentElement, kind, stretchLevel, position) {
    let symbolElement = parentElement.children[0];
    symbolElement.textContent = DATA["wide"][kind][position][stretchLevel];
  }

  appendStretch(contentElement, parentElement, kind, position) {
    let stretchElement = document.createElement("math-hstretch");
    let hasStart = !!DATA["wide"][kind][position]["start"];
    let hasEnd = !!DATA["wide"][kind][position]["end"];
    let hasMiddle = !!DATA["wide"][kind][position]["middle"];
    let startElement = null;
    let endElement = null;
    let middleElement = null;
    if (hasStart) {
      startElement = document.createElement("math-start");
      startElement.textContent = DATA["wide"][kind][position]["start"];
      stretchElement.append(startElement);
    }
    if (hasMiddle) {
      middleElement = document.createElement("math-middle");
      middleElement.textContent = DATA["wide"][kind][position]["middle"];
      stretchElement.append(middleElement);
    }
    if (hasEnd) {
      endElement = document.createElement("math-end");
      endElement.textContent = DATA["wide"][kind][position]["end"];
      stretchElement.append(endElement);
    }
    parentElement.removeChild(parentElement.children[0]);
    parentElement.appendChild(stretchElement);
    let barSize = (hasMiddle) ? 2 : 1;
    let barWidth = this.calcBarWidth(contentElement, startElement, endElement, middleElement);
    for (let i = 0 ; i < barSize ; i ++) { 
      let barWrapperElement = document.createElement("math-barwrap");
      let barElement = document.createElement("math-bar");
      barElement.textContent = DATA["wide"][kind][position]["bar"];
      barWrapperElement.style.width = "" + barWidth + "em";
      barWrapperElement.append(barElement);
      if (i == 0) {
        stretchElement.insertBefore(barWrapperElement, stretchElement.children[(hasStart) ? 1 : 0]);
      } else {
        stretchElement.insertBefore(barWrapperElement, stretchElement.children[(hasStart) ? 3 : 2]);
      }
    }
  }

  calcKind(element) {
    let kind = "widetilde";
    if (element.getAttribute("data-kind")) {
      kind = element.getAttribute("data-kind");
    }
    return kind;
  }

  calcMaxStretchLevel(kind, position) {
    let keys = Object.keys(DATA["wide"][kind][position]);
    let maxStretchLevel = -1;
    for (let key of keys) {
      if (key.match(/^\d+$/) && DATA["wide"][kind][position][key] && parseInt(key) > maxStretchLevel) {
        maxStretchLevel = parseInt(key);
      }
    }
    return maxStretchLevel;
  }

  calcStretchLevel(element, kind, position) {
    let widthAbs = this.getWidth(element) * 1000;
    let maxStretchLevel = this.calcMaxStretchLevel(kind, position);
    let stretchLevel = null;
    for (let i = 0 ; i <= maxStretchLevel ; i ++) {
      if (widthAbs <= DATA["wide"][kind][position]["width"][i]) {
        stretchLevel = i;
        break;
      }
    }
    if (stretchLevel == null && !DATA["wide"][kind][position]["bar"]) {
      stretchLevel = maxStretchLevel;
    }
    return stretchLevel;
  }

  calcBarWidth(element, startElement, endElement, middleElement) {
    let wholeWidth = this.getWidth(element);
    let startWidth = (startElement) ? this.getWidth(startElement) : 0;
    let endWidth = (endElement) ? this.getWidth(endElement) : 0;
    let middleWidth = (middleElement) ? this.getWidth(middleElement) : 0;
    let width = wholeWidth - startWidth - endWidth - middleWidth;
    if (middleElement) {
      width = width / 2;
    }
    if (width < 0) {
      width = 0;
    }
    return width;
  }

}
//


class AccentModifier extends Modifier {

  modify(element) {
    let baseWrapperElement = this.findChild(element, "math-basewrap");
    let overElement = this.findChild(element, "math-over");
    let contentElement = baseWrapperElement.children[0];
    let parentElements = [baseWrapperElement.children[1], overElement];
    for (let position of [0, 1]) {
      let parentElement = parentElements[position];
      if (parentElement) {
        this.modifyPosition(contentElement, parentElement, position);
      }
    }
  }

  modifyPosition(contentElement, parentElement, position) {
    let charElement = contentElement.children[0];
    let string = charElement && charElement.textContent;
    if (string && string.length == 1 && contentElement.children.length == 1) {
      let char = string.substring(0, 1);
      let shift = DATA["shift"][position][char];
      if (shift) {
        let marginString;
        if (position == 0) {
          marginString = window.getComputedStyle(parentElement).marginTop;
        } else {
          marginString = window.getComputedStyle(parentElement).marginBottom;
        }
        let margin = parseFloat(marginString) / this.getFontSize(parentElement);
        if (position == 0) {
          parentElement.style.marginTop = "" + (margin + shift) + "em";
        } else {
          parentElement.style.marginBottom = "" + (margin - shift) + "em";
        }
      }
    }
  }

}
//


class UnderoverModifier extends Modifier {

  modify(element) {
  }

}
window.onload = () => Modifier.execute();